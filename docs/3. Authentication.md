# 3. Authentication

## Endpoint Security Type
	API requests are likely to be tampered during transmission through the internet.
	To ensure that the request remains unchanged, all private interfaces other than
	public interfaces (basic information, market data) must be verified by signature
	authentication via EXCHANGE-API-KEY to make sure the parameters or configurations
	are unchanged during transmission.

	Each created API-KEY need to be assigned with appropriate permissions in order to
	access the corresponding interface. Before using the interface, users is required to
	check the permission type for each interface and confirm there is appropriate permissions.

| Authentication Type | Description |
| --- | --- |
| Market | Endpoints are freely accessible |
| Account | Endpoints requires sending a valid EXCHANGE-API-KEY and signature |
| Order | Endpoints requires sending a valid EXCHANGE-API-KEY and signature |



## Signature Authentication
--------------------------------------------------------------------
`If you are going to access the **Account & Order** related api interface,
you need to add the **EXCHANGE-API-SIGN** field in the header, and it needs
to have a legal and correct value.`

| Column | Description |
| --- | --- |
| EXCHANGE-API-KEY | Apply on the User Center-API page |
| EXCHANGE-API-TIMESTAMP | The timestamp at which the request was initiated |
| EXCHANGE-API-SIGN | Encrypted and signed string for parameters |

`if you are going to access the **Market** related api interface ,
the **EXCHANGE-API-KEY**、**EXCHANGE-API-SIGN** field is not required,
but the **EXCHANGE-API-TIMESTAMP** field is required.`

## Signature


* The SIGNED (signature required) endpoint needs to send a parameter, signature, in the **query string** or **request body**.

* The request needs to be signed with the ed225519 private key. The resulting signature needs to be pasted into the request header as {"EXCHANGE-API-SIGN": "your_signature"}

* Signature is not case sensitive.

* totalParams refers to concatenation of the query string and the request body.

All HTTP requests to API endpoints require authentication and authorization. The following headers should be added to all HTTP requests:

| Key | Value | Type | Description |
| --- | --- | --- | --- |
| EXCHANGE-API-KEY | API-KEY | String | The API-KEY (let's use upper case consistently throughout the document) that DFX generates for the client after the ed25519 public key is uploaded to the DFX platform. |
| EXCHANGE-API-SIGN | PARAM SIGN | String | The signature of the request. The request is signed by the client's ed25519 private key.|
| EXCHANGE-API-TIMESTAMP | TIMESTAMP  | Long | milliseconds, such as 1706772548231, Used to indicate the time when the request was initiated |

#### Time-base security requirement
    If your timestamp is ahead of serverTime it needs to be within 5 Seconds

*   For a SIGNED endpoint, an additional parameter "EXCHANGE-API-TIMESTAMP" needs to be included in the request header. This timestamp is in **milliseconds** and reflect the time when the request was intitated
*   The timestamp is based on the server's time and cannot exceed 5 Seconds before or after.
*   Trading and timeliness are closely interconnected. Network can sometimes be unstable or unreliable, which can lead to inconsistent times when requests are sent to the server.




### How to sign request parameters


#### tip

The following fields need to be filled in when signing, and then sorted in ascending order according to the parameter name. The finally sorted string will be encrypted.

| Parameter| Description |
| --- | --- |
| body| The query param in request body |
| method| request type，eg:POST、GET、DELETE |
| param| The query param in request param|
| path | This path is the real path requested by the interface caller. like /api/v1/symbols |
| timestamp| timestamp in milliseconds |


#### warn
1. The above parameter fields need to be sorted in ascending order and be concatenated
	with a separator character: “&”. Signature verification will fail if the order is wrong
	or if the parameter names are wrong.
2. You only need to sort `body`, `method`, `param`, `path`, `timestamp`, and there is no
 need to sort the values inside parm and body. For example, param=BAC does not need to be
 sorted into param=ABC! The same applies to the body field.

### Python Example
``` python
import datetime
import time
import pprint
import logging
from typing import Dict, Tuple, List, Any, Union
import requests
from cryptography.hazmat.primitives.serialization import load_pem_private_key

API_VERSION = "v1"
EXCHANGE_API_KEY = "YOUR_EXCHANGE_API_KEY"
PRIVATE_KEY_PATH = "YOUR_PEM_PRIVATE_KEY_PATH"

def get_account_info(self) -> dict:
    path = f'/api/{API_VERSION}/user/info'
    params = dict()
    rsp = self._req('GET', path, params, to_sign=True)
    if rsp and rsp['code'] == '0' and 'data' in rsp:
        if rsp['data']:
 	    return rsp
    return dict()

def _req(self, method: str, path: str, params: dict, to_sign: bool):
    url = API_REST_URL + path
    headers = construct_header(method, path, params, to_sign)
    with requests.Session() as session:
        try:
            if method == 'GET':
                rsp = session.get(url=url, headers=headers, params=params, timeout=self._timeout)
            elif method == 'POST':
                rsp = session.post(url=url, headers=headers, params=params, timeout=self._timeout)
            elif method == 'DELETE':
                rsp = session.delete(url=url, headers=headers, params=params, timeout=self._timeout)
            else:
                return None
        except Exception as e:
            return None
        if rsp:
            return handle_response(rsp)
        else:
            return None

def construct_header(self, method: str, path: str, params: dict, to_sign: bool) -> Dict[str, str]:
    ts = str(int(time.time() * 1e3))
    header: dict = {'EXCHANGE-API-KEY': EXCHANGE_API_KEY,
                    'EXCHANGE-API-TIMESTAMP': ts}
    if to_sign:
        header.update({'EXCHANGE-API-SIGN': signature(method, path, params, ts)})
    return header
	
def signature(priv_key: Ed25519PrivateKey, method: str, path: str, param: dict, ts: str) -> str:
    with open(PRIVATE_KEY_PATH, 'rb') as key_file:
        private_key = load_pem_private_key(key_file.read(), password=None)
    p = '&'.join(f'{k}={v}' for k, v in param.items())
    if param:
        msg = {'method': method, 'param': p, 'path': path, 'timestamp': ts}
    else:
        msg = {'method': method, 'path': path, 'timestamp': ts}
    z = '&'.join(f'{k}={v}' for k, v in sorted(msg.items())).encode()
    res = base64.b64encode(private_key.sign(z)).decode()
    return str(res)

def handle_response(rsp: requests.Response):
    if rsp.status_code == 200:
        try:
            data = rsp.json()
            return data
        except Exception as e:
            return None
    else:
        return None
 

###  Java example 1: param in queryString



``` java
* Step 1.If your request parameters are as follows
*
* apiUrl：https://$HOST/api/v1/symbols
* method: GET
* timestamp: 1711351755000
* param: `clientType=OP`
* body: null

```


``` markdown
* Step 2.Example Code

import cn.hutool.core.util.StrUtil;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.Security;
import java.security.Signature;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;
import java.util.Map;
import java.util.TreeMap;

public class SignatureExample {
	public static void main(String[] args) throws Exception {
		Security.addProvider(new BouncyCastleProvider());
		String timestamp = "1711351755000";
		String method = "GET";
		String path = "/api/v1/symbols";
		String param = "clientType=OP";
		String body = "";

		Map<String, String> paramMap = new TreeMap<>();
		paramMap.put("path", path);
		paramMap.put("method", method);
		paramMap.put("timestamp", timestamp);
		if (StrUtil.isNotBlank(param)) {
			paramMap.put("param", param);
		}
		if (StrUtil.isNotBlank(body)) {
			paramMap.put("body", body);
		}

		String message = StrUtil.join("&", paramMap.entrySet().iterator());

		Signature signature = Signature.getInstance("Ed25519", "BC");
		byte[] privateKeyBytes = Files.readAllBytes(Paths.get("/Users/local/private_key.pem"));

		// Convert private key bytes to PrivateKey object
		PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes);
		KeyFactory keyFactory = KeyFactory.getInstance("Ed25519");
		PrivateKey privateKey = keyFactory.generatePrivate(keySpec);
		signature.initSign(privateKey);
		signature.update(message.getBytes());
		byte[] signatureBytes = signature.sign();
		// Print signature results
		String signResult = Base64.getEncoder().encodeToString(signatureBytes);
		System.out.println("private Signature: " + signResult);
	}
}
```

``` java
* Step 3. Send Request

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

public class HttpGetExample {
	public static void main(String[] args) throws IOException {
		String url = "https://$HOST/api/v1/symbols?clientType=OP";
		HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();
		connection.setRequestMethod("GET");

		// Set request header
		connection.setRequestProperty("EXCHANGE-API-KEY", "YOUR API-KEY");
		connection.setRequestProperty("EXCHANGE-API-TIMESTAMP", "1711351755000");
		connection.setRequestProperty("EXCHANGE-API-SIGN", signResult);


		int responseCode = connection.getResponseCode();
		System.out.println("Response Code: " + responseCode);

		BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
		StringBuilder response = new StringBuilder();
		String line;
		while ((line = reader.readLine()) != null) {
			response.append(line);
		}
		reader.close();

		System.out.println("Response Body: " + response.toString());

		connection.disconnect();
	}
}


```


###  Java Example 2: param in body

``` markdown
* Step 1.If your request parameters are as follows
*
* apiUrl：https://$HOST/api/v1/spot/order
* method: POST
* timestamp: 1711351755000
* param: null
* body:`accountId=222&amount=66666&clientOrderId=111&price=66666&quantity=1&side=BUY&symbol=BTC-USDT&type=LIMIT`

```


``` java
* Step 2.Example Code

import cn.hutool.core.util.StrUtil;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.Security;
import java.security.Signature;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;
import java.util.Map;
import java.util.TreeMap;

public class SignatureExample {
	public static void main(String[] args) throws Exception {
		Security.addProvider(new BouncyCastleProvider());
		String timestamp = "1711351755000";
		String method = "GET";
		String path = "/api/v1/spot/order";
		String param = "";
		String body = "accountId=222&amount=66666&clientOrderId=111&price=66666&quantity=1&side=BUY&symbol=BTC-USDT&type=LIMIT";

		Map<String, String> paramMap = new TreeMap<>();
		paramMap.put("path", path);
		paramMap.put("method", method);
		paramMap.put("timestamp", timestamp);
		if (StrUtil.isNotBlank(param)) {
			paramMap.put("param", param);
		}
		if (StrUtil.isNotBlank(body)) {
			paramMap.put("body", body);
		}

		String message = StrUtil.join("&", paramMap.entrySet().iterator());

		Signature signature = Signature.getInstance("Ed25519", "BC");
		byte[] privateKeyBytes = Files.readAllBytes(Paths.get("/Users/local/private_key.pem"));

		// Convert private key bytes to PrivateKey object
		PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes);
		KeyFactory keyFactory = KeyFactory.getInstance("Ed25519");
		PrivateKey privateKey = keyFactory.generatePrivate(keySpec);
		signature.initSign(privateKey);
		signature.update(message.getBytes());
		byte[] signatureBytes = signature.sign();
		// Print signature results
		String signResult = Base64.getEncoder().encodeToString(signatureBytes);
		System.out.println("private Signature: " + signResult);
	}
}
```

``` java

* Step 3. Send Request

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;

public class HttpPostExample {
	public static void main(String[] args) throws IOException {
		// interface address
		String url = "https://$HOST/api/v1/spot/order";
		// Request body data
		String requestBody = "accountId=222&amount=66666&clientOrderId=111&price=66666&quantity=1&side=BUY&symbol=BTC-USDT&type=LIMIT";

		// Create HttpURLConnection object
		HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();
		connection.setRequestMethod("POST");
		connection.setDoOutput(true);

		// Set request header
						connection.setRequestProperty("EXCHANGE-API-KEY", "YOUR API-KEY");
						connection.setRequestProperty("EXCHANGE-API-TIMESTAMP", "1711351755000");
						connection.setRequestProperty("EXCHANGE-API-SIGN", signResult);
		// Set request body data
		try (DataOutputStream wr = new DataOutputStream(connection.getOutputStream())) {
			wr.write(requestBody.getBytes(StandardCharsets.UTF_8));
		}

		// Make a request and get a response
		try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
			String line;
			StringBuilder response = new StringBuilder();
			while ((line = in.readLine()) != null) {
				response.append(line);
			}
			System.out.println("Response: " + response.toString());
		}

		// close connection
		connection.disconnect();
	}
}



```




###  Java Example 3: mixing queryString and request body


``` java
* Step 1.If your request parameters are as follows
*
    * apiUrl：https://$HOST/api/v1/symbols
* method: POST
* timestamp: 1711351755000
* param: `clientType=OP`
* body:  `pageNo=1&pageSize=10`

    ```


    ``` markdown
* Step 2.Example Code

import cn.hutool.core.util.StrUtil;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.Security;
import java.security.Signature;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;
import java.util.Map;
import java.util.TreeMap;

public class SignatureExample {
	public static void main(String[] args) throws Exception {
		Security.addProvider(new BouncyCastleProvider());
		String timestamp = "1711351755000";
		String method = "GET";
		String path = "/api/v1/symbols";
		String param = "clientType=OP";
		String body = "pageNo=1&pageSize=10";

		Map<String, String> paramMap = new TreeMap<>();
		paramMap.put("path", path);
		paramMap.put("method", method);
		paramMap.put("timestamp", timestamp);
		if (StrUtil.isNotBlank(param)) {
			paramMap.put("param", param);
		}
		if (StrUtil.isNotBlank(body)) {
			paramMap.put("body", body);
		}

		String message = StrUtil.join("&", paramMap.entrySet().iterator());

		Signature signature = Signature.getInstance("Ed25519", "BC");
		byte[] privateKeyBytes = Files.readAllBytes(Paths.get("/Users/local/private_key.pem"));

		// 将私钥字节转换为 PrivateKey 对象
		PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes);
		KeyFactory keyFactory = KeyFactory.getInstance("Ed25519");
		PrivateKey privateKey = keyFactory.generatePrivate(keySpec);
		signature.initSign(privateKey);
		signature.update(message.getBytes());
		byte[] signatureBytes = signature.sign();
		// 打印签名结果
		String signResult = Base64.getEncoder().encodeToString(signatureBytes);
		System.out.println("private Signature: " + signResult);
	}
}
```

``` java
* Step 3. Send Request

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;

public class HttpPostExample {
	public static void main(String[] args) throws IOException {
		// interface address
		String url = "https://$HOST/api/v1/symbols?clientType=OP";
		// Request body data
		String requestBody = "pageNo=1&pageSize=10";

		// Create HttpURLConnection object
		HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();
		connection.setRequestMethod("POST");
		connection.setDoOutput(true);

		// Set request header
						connection.setRequestProperty("EXCHANGE-API-KEY", "YOUR API-KEY");
						connection.setRequestProperty("EXCHANGE-API-TIMESTAMP", "1711351755000");
						connection.setRequestProperty("EXCHANGE-API-SIGN", signResult);
		// Set request body data
		try (DataOutputStream wr = new DataOutputStream(connection.getOutputStream())) {
			wr.write(requestBody.getBytes(StandardCharsets.UTF_8));
		}

		// Make a request and get a response
		try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
			String line;
			StringBuilder response = new StringBuilder();
			while ((line = in.readLine()) != null) {
				response.append(line);
			}
			System.out.println("Response: " + response.toString());
		}

		// close connection
		connection.disconnect();
	}
}



```
